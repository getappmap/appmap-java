diff --git a/.gitignore b/.gitignore
index 5379097..1343470 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,7 +4,7 @@
 # Ignore Gradle build output directory
 build
 
-# Appmap files
+# AppMap files
 tmp
 
 .classpath
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
index 0255334..fb7f4a8 100644
--- a/.idea/compiler.xml
+++ b/.idea/compiler.xml
@@ -1,15 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <annotationProcessing>
-      <profile name="Gradle Imported" enabled="true">
-        <outputRelativeToContentRoot value="true" />
-        <processorPath useClasspath="false">
-          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/info.picocli/picocli/4.0.4/28c5aafb118876f644aae30bdcbd89ae27b198a8/picocli-4.0.4.jar" />
-          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/info.picocli/picocli-codegen/4.0.4/93f1281132877e4a68b454552ec52bb4d1098055/picocli-codegen-4.0.4.jar" />
-        </processorPath>
-        <module name="appmap-java.main" />
-      </profile>
-    </annotationProcessing>
+    <bytecodeTargetLevel target="11" />
   </component>
 </project>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 25d34a4..a4ceb47 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -1,5 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="EntryPointsManager">
+    <writeAnnotations>
+      <writeAnnotation name="picocli.CommandLine.ParentCommand" />
+    </writeAnnotations>
+  </component>
   <component name="ExternalStorageConfigurationManager" enabled="true" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_11" project-jdk-name="11" project-jdk-type="JavaSDK" />
+  <component name="FrameworkDetectionExcludesConfiguration">
+    <file type="web" url="file://$PROJECT_DIR$" />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK" />
 </project>
\ No newline at end of file
diff --git a/appmap.yml b/appmap.yml
index 618a5bd..3a621bf 100644
--- a/appmap.yml
+++ b/appmap.yml
@@ -1,7 +1,6 @@
-name: AppMap - Java
+name: appmap-java
 packages:
 - path: com.appland.appmap.test.util
   exclude:
   - com.appland.appmap.test.util.UnhandledExceptionCollection
-
 - exclude: [ com.appland.appmap.integration.RecorderTest ]
diff --git a/build.gradle b/build.gradle
index 3e2f12e..f9c7a70 100644
--- a/build.gradle
+++ b/build.gradle
@@ -22,51 +22,43 @@ repositories {
 }
 
 // hardcoded -- could be redefined via env variables and project properties (see below)
-def parameterizedVersion    = findProperty('appMapAgentVersion')
-def travisVersion           = System.getenv("TRAVIS_BRANCH")
-def defaultVersion          = '1.1.0'
+def parameterizedVersion = findProperty('appMapAgentVersion')
+def travisVersion = System.getenv("TRAVIS_BRANCH")
+def defaultVersion = '1.2.0'
 
-def versionLikeRegexp       = /^\d+\.\d+.*/
-def travisVersionValid      = travisVersion && (travisVersion ==~ versionLikeRegexp)
+def versionLikeRegexp = /^\d+\.\d+.*/
+def travisVersionValid = travisVersion && (travisVersion ==~ versionLikeRegexp)
 
-version = parameterizedVersion ?: ( travisVersionValid ? travisVersion : defaultVersion )
+version = parameterizedVersion ?: (travisVersionValid ? travisVersion : defaultVersion)
 
-def defaultGitSlug="applandinc/appmap-java"
-def currentGitSlug=System.getenv("TRAVIS_REPO_SLUG") ?: defaultGitSlug
+def defaultGitSlug = "applandinc/appmap-java"
+def currentGitSlug = System.getenv("TRAVIS_REPO_SLUG") ?: defaultGitSlug
 
-def defaultGroupId      = 'com.appland'
-def defaultArtifactId   = 'appmap-agent'
-def publishGroupId      = findProperty('publishGroupId') ?: defaultGroupId
-def publishArtifactId   = findProperty('publishArtifactId') ?: defaultArtifactId
+def defaultGroupId = 'com.appland'
+def defaultArtifactId = 'appmap-agent'
+def publishGroupId = findProperty('publishGroupId') ?: defaultGroupId
+def publishArtifactId = findProperty('publishArtifactId') ?: defaultArtifactId
 
 dependencies {
-  implementation 'org.yaml:snakeyaml:1.25'
   implementation 'com.alibaba:fastjson:1.2.61'
   implementation 'org.javassist:javassist:3.27.0-GA'
   implementation 'org.reflections:reflections:0.9.11'
   implementation 'javax.servlet:javax.servlet-api:4.0.1'
   implementation 'org.apache.commons:commons-lang3:3.10'
+  implementation 'org.yaml:snakeyaml:1.29'
   implementation 'org.slf4j:slf4j-nop:1.7.30'
-
-  /*
-  /// are test classes becoming part of "build" purposedly or by mistake?
-  implementation 'junit:junit:4.12'
-  implementation 'com.github.stefanbirkner:system-rules:1.19.0'
-  //implementation "org.mockito:mockito-core:2.+" # maven requires  strict syntax
-  implementation "org.mockito:mockito-core:2.28.2"
-  compile 'com.github.stefanbirkner:system-rules:1.19.0'
-  */
+  implementation 'info.picocli:picocli:4.6.1'
 
   testImplementation 'junit:junit:4.12'
   testImplementation 'com.github.stefanbirkner:system-rules:1.19.0'
-  //testImplementation "org.mockito:mockito-core:2.+"
   testImplementation "org.mockito:mockito-core:2.28.2"
-
 }
 
 jar {
   manifest {
     attributes 'Premain-Class': 'com.appland.appmap.Agent'
+    attributes 'Main-Class': 'com.appland.appmap.cli.CLI'
+    attributes 'Implementation-Version': version
   }
 }
 
@@ -82,16 +74,9 @@ shadowJar {
 }
 
 sourceSets {
-  /*
-  main {
-    java {
-      srcDirs = ['src/main']
-    }
-  }
-  */
   integrationTest {
     java {
-      srcDirs = [ 'src/test/java/com/appland/appmap/integration' ]
+      srcDirs = ['src/test/java/com/appland/appmap/integration']
     }
     compileClasspath += main.output + test.output + sourceSets.test.compileClasspath
     runtimeClasspath += main.output + test.output + sourceSets.test.runtimeClasspath
@@ -99,7 +84,7 @@ sourceSets {
 }
 
 task integrationTest(type: Test) {
-  description = 'Runs integration tests.'
+  description = 'Runs integration tests'
   group = 'verification'
 
   testClassesDirs = sourceSets.integrationTest.output.classesDirs
@@ -120,12 +105,12 @@ test {
 }
 
 task relocateShadowJar(type: ShadowRelocation) {
-    target = tasks.shadowJar
-    prefix = "com.appland.shade"
-    excludes = [
-      "javax.",
-      "java."
-    ]
+  target = tasks.shadowJar
+  prefix = "com.appland.shade"
+  excludes = [
+    "javax.",
+    "java."
+  ]
 }
 
 tasks.shadowJar.dependsOn tasks.relocateShadowJar
@@ -140,118 +125,109 @@ jacocoTestReport {
 
 // extra artifacts used in publishing
 task sourcesJar(type: Jar) {
-    from sourceSets.main.allJava
-    classifier = 'sources'
+  from sourceSets.main.allJava
+  classifier = 'sources'
 }
 
 // for some reason this block generates empty Javadoc
 // which we use as a workaround to bypass javadoc errors issue
 javadoc {
-    exclude 'com/appland/**'
+  exclude 'com/appland/**'
 }
 task mockJavadocJar(type: Jar) {
-    classifier = 'javadoc'
-    from javadoc.destinationDir
+  classifier = 'javadoc'
+  from javadoc.destinationDir
 }
 
 apply plugin: 'maven-publish'
 publishing {
   publications {
 
-        appMapAgent(MavenPublication) {
-
-            // requirements: https://central.sonatype.org/pages/requirements.html
-
-            // 1. coordinates (parameterized)
-
-            groupId     publishGroupId
-            artifactId  publishArtifactId
-
-            // version defined globally
-
-            // 2. artifacts
-            // inclusion of javadoc and source jars is Maven-Central requirement
-
-            artifact shadowJar
-            artifact sourcesJar
-            artifact mockJavadocJar // empty javadoc generated until errors are fixed
-
-            //// the artifacts below added automatically by `java { with... }` block above
-            // artifact sourcesJar
-            // artifact javadocJar
-
-            // metadata
-            // TBD: parameterize more values?
-
-            pom {
-                name = "$publishGroupId:$publishArtifactId"
-                description = "Inspect and record the execution of Java for use with App Land"
-                url = "https://appland.com"
-
-                licenses {
-                  license {
-                    name = "MIT"
-                    url = "https://raw.githubusercontent.com/$currentGitSlug/master/LICENSE.txt"
-                  }
-                }
-                developers {
-                  developer {
-                    // id = "kgilpin"
-                    name = "Kevin Gilpin"
-                    email = "kevin@appland.com"
-                    organization = "AppLand Inc."
-                    url="https://dev.to/kgilpin"
-                  }
-                }
-                scm {
-                    connection = "scm:git:git://github.com/${currentGitSlug}.git"
-                    developerConnection = "scm:git:ssh://github.com:${currentGitSlug}.git"
-                    url = "https://github.com/${currentGitSlug}/tree/master"
-                }
-            }
-        }
-  }
+    appMapAgent(MavenPublication) {
 
-   repositories {
+      // requirements: https://central.sonatype.org/pages/requirements.html
 
-        def local_url       = "file://${buildDir}/repo"
-        // see https://central.sonatype.org/pages/gradle.html
-        def default_base        = "https://s01.oss.sonatype.org"
-        //def default_base    = "https://oss.sonatype.org"
-        def url_base        = findProperty("mavenRepoURL") ?: default_base
-        def staging_url     = url_base + "/service/local/staging/deploy/maven2/"
-        def snapshots_url   = url_base + "/content/repositories/snapshots/"
+      // 1. coordinates (parameterized)
 
-        def is_snapshot     = version.endsWith('SNAPSHOT')
-        def remote_url      = is_snapshot ? snapshots_url : staging_url
+      groupId publishGroupId
+      artifactId publishArtifactId
 
-        def ossrh_username  = findProperty('ossrhUsername')
+      // version defined globally
 
+      // 2. artifacts
+      // inclusion of javadoc and source jars is Maven-Central requirement
 
-        maven {
-            if (ossrh_username) {
-                url = remote_url
-                credentials {
-                    username = ossrh_username
-                    password = getProperty('ossrhPassword')
-                }
-            } else {
-                url = local_url
-            }
-        }
-    }
-}
+      artifact shadowJar
+      artifact sourcesJar
+      artifact mockJavadocJar // empty javadoc generated until errors are fixed
 
+      //// the artifacts below added automatically by `java { with... }` block above
+      // artifact sourcesJar
+      // artifact javadocJar
 
+      // metadata
+      // TBD: parameterize more values?
 
-if (project.hasProperty("signingKey")) {
+      pom {
+        name = "$publishGroupId:$publishArtifactId"
+        description = "Inspect and record the execution of Java for use with App Land"
+        url = "https://appland.com"
 
-    apply plugin: 'signing'
+        licenses {
+          license {
+            name = "MIT"
+            url = "https://raw.githubusercontent.com/$currentGitSlug/master/LICENSE.txt"
+          }
+        }
+        developers {
+          developer {
+            // id = "kgilpin"
+            name = "Kevin Gilpin"
+            email = "kevin@appland.com"
+            organization = "AppLand Inc."
+            url = "https://dev.to/kgilpin"
+          }
+        }
+        scm {
+          connection = "scm:git:git://github.com/${currentGitSlug}.git"
+          developerConnection = "scm:git:ssh://github.com:${currentGitSlug}.git"
+          url = "https://github.com/${currentGitSlug}/tree/master"
+        }
+      }
+    }
+  }
 
-    signing {
-        def signingKey = findProperty("signingKey")
-        def signingPassword = findProperty("signingPassword")
-        useInMemoryPgpKeys(signingKey, signingPassword)
-        sign publishing.publications.appMapAgent
+  repositories {
+    def local_url = "file://${buildDir}/repo"
+    // see https://central.sonatype.org/pages/gradle.html
+    def default_base = "https://s01.oss.sonatype.org"
+    def url_base = findProperty("mavenRepoURL") ?: default_base
+    def staging_url = url_base + "/service/local/staging/deploy/maven2/"
+    def snapshots_url = url_base + "/content/repositories/snapshots/"
+    def is_snapshot = version.endsWith('SNAPSHOT')
+    def remote_url = is_snapshot ? snapshots_url : staging_url
+    def ossrh_username = findProperty('ossrhUsername')
+
+    maven {
+      if (ossrh_username) {
+        url = remote_url
+        credentials {
+          username = ossrh_username
+          password = getProperty('ossrhPassword')
+        }
+      } else {
+        url = local_url
+      }
     }
+  }
+}
+
+if (project.hasProperty("signingKey")) {
+  apply plugin: 'signing'
+  signing {
+    def signingKey = findProperty("signingKey")
+    def signingPassword = findProperty("signingPassword")
+    useInMemoryPgpKeys(signingKey, signingPassword)
+    sign publishing.publications.appMapAgent
+  }
 }
diff --git a/src/main/java/com/appland/appmap/cli/CLI.java b/src/main/java/com/appland/appmap/cli/CLI.java
new file mode 100644
index 0000000..ea422ef
--- /dev/null
+++ b/src/main/java/com/appland/appmap/cli/CLI.java
@@ -0,0 +1,54 @@
+package com.appland.appmap.cli;
+
+import picocli.CommandLine;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@CommandLine.Command()
+public class CLI {
+  private static final Object STDOUT_CONST = new Object();
+
+  @CommandLine.Option(names = { "-d", "--directory" }, description = "Project directory", required = true)
+  public String directory;
+
+  @CommandLine.Option(names = { "-o", "--output-file" }, description = "File to receive the output. Default: stdout")
+  public Object outputFileName = STDOUT_CONST;
+
+  Map<Object, PrintStream> streams = new ConcurrentHashMap<>();
+
+  {
+    streams.put(STDOUT_CONST, System.out);
+  }
+
+  public PrintStream getOutputStream() {
+    return streams.computeIfAbsent(this.outputFileName, (fileName) -> {
+      System.err.printf("Directing command output to: %s\n", this.outputFileName.toString());
+      try {
+        return new PrintStream(new FileOutputStream(this.outputFileName.toString()));
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    });
+  }
+
+  public static void main(String[] args) {
+    int exitCode = new CommandLine(new CLI())
+        .addSubcommand("status", Status.class)
+        .addSubcommand("init", Init.class)
+        .execute(args);
+    System.exit(exitCode);
+  }
+
+  public static String projectName(File directory) {
+    try {
+      return directory.getCanonicalFile().getName();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/src/main/java/com/appland/appmap/cli/Init.java b/src/main/java/com/appland/appmap/cli/Init.java
new file mode 100644
index 0000000..eb78be5
--- /dev/null
+++ b/src/main/java/com/appland/appmap/cli/Init.java
@@ -0,0 +1,121 @@
+package com.appland.appmap.cli;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.annotation.JSONField;
+import com.alibaba.fastjson.serializer.SerializerFeature;
+import picocli.CommandLine;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.function.Consumer;
+
+@CommandLine.Command(name = "init", description = "Suggests AppMap configuration settings for a new project.")
+public class Init implements Callable<Integer> {
+  @CommandLine.ParentCommand
+  private CLI parent;
+
+  static class Configuration {
+    @JSONField
+    public String filename;
+
+    @JSONField
+    public String contents;
+  }
+
+  static class Result {
+    @JSONField
+    public Configuration configuration;
+  }
+
+  public Integer call() throws Exception {
+    System.err.printf("Init AppMap project configuration in directory: %s\n", parent.directory);
+
+    StringWriter sw = new StringWriter();
+    PrintWriter pw = new PrintWriter(sw);
+    pw.println("# This is the AppMap configuration file.");
+    pw.println("# For full documentation of this file for Java programs, see:");
+    pw.println("# https://appland.com/docs/reference/appmap-java.html#configuration");
+    pw.format("name: %s\n", CLI.projectName(new File(parent.directory)));
+
+    // For now, this only works in this type of standardize repo structure.
+    File javaDir = new File("src/main/java");
+    if (javaDir.isDirectory()) {
+      // Collect package names in src/main/java
+      Set<Path> packages = new HashSet<>();
+      Files.walkFileTree(javaDir.toPath(), new SimpleFileVisitor<Path>() {
+        @Override
+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
+          if (file.getFileName().toString().endsWith(".java")) {
+            Path packagePath = pathPackage(file.getParent());
+            if (packagePath != null) {
+              packages.add(packagePath);
+            }
+          }
+          return FileVisitResult.CONTINUE;
+        }
+      });
+
+      pw.println("# Your project contains the directory src/main/java.");
+      pw.println("# AppMap has auto-detected the following Java packages in this directory:");
+      pw.println("packages:");
+      // Collect just the packages that don't have a matching ancestor in the package list.
+      List<Path> topLevelPackages = packages.stream().sorted().collect(ArrayList::new, (memo, packagePath) -> {
+        for (int i = 1; i < packagePath.getNameCount(); i++) {
+          Path ancestorPath = packagePath.subpath(0, i);
+          if (memo.contains(ancestorPath)) {
+            return;
+          }
+        }
+        memo.add(packagePath);
+      }, ArrayList::addAll);
+      topLevelPackages.forEach(new Consumer<Path>() {
+        @Override
+        public void accept(Path packagePath) {
+          List<String> tokens = new ArrayList<>();
+          for (int i = 0; i < packagePath.getNameCount(); i++) {
+            tokens.add(packagePath.getName(i).toString());
+          }
+          String path = String.join(".", tokens);
+          pw.format("- path: %s\n", path);
+        }
+      });
+    } else {
+      pw.println("packages: []");
+      pw.println("# appmap-java init looks for source packages in src/main/java.");
+      pw.println("# This folder was not found in your project, so no packages were auto-detected.");
+      pw.println("# You can add your source packages by replacing the line above with lines like this:");
+      pw.println("# packages:");
+      pw.println("# - path: com.mycorp.pkg");
+      pw.println("# - path: org.otherstuff.pkg");
+    }
+
+    Configuration configuration = new Configuration();
+    configuration.filename = "appmap.yml";
+    configuration.contents = sw.toString();
+    Result result = new Result();
+    result.configuration = configuration;
+
+    parent.getOutputStream().println(JSON.toJSONString(result, SerializerFeature.PrettyFormat));
+
+    return 0;
+  }
+
+  private static Path pathPackage(Path dir) {
+    if (dir.getNameCount() <= 3) {
+      return null;
+    }
+
+    return dir.subpath(3, dir.getNameCount());
+  }
+}
diff --git a/src/main/java/com/appland/appmap/cli/Status.java b/src/main/java/com/appland/appmap/cli/Status.java
new file mode 100644
index 0000000..78698ac
--- /dev/null
+++ b/src/main/java/com/appland/appmap/cli/Status.java
@@ -0,0 +1,241 @@
+package com.appland.appmap.cli;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.annotation.JSONField;
+import com.alibaba.fastjson.serializer.SerializerFeature;
+import org.yaml.snakeyaml.Yaml;
+import picocli.CommandLine;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+@CommandLine.Command(name = "status", description = "Prints AppMap status of the Java project in a specified directory.")
+public class Status implements Callable<Integer> {
+  @CommandLine.ParentCommand
+  private CLI parent;
+
+  static class Program {
+    public String name;
+    public String[] platforms;
+
+    Program(String name, String[] platforms) {
+      this.name = name;
+      this.platforms = platforms;
+    }
+  }
+
+  static class Command {
+    public String program;
+    public List<String> args = new ArrayList<>();
+    public Map<String, String> environment = new HashMap<>();
+    public List<String> platforms;
+  }
+
+  static class TestCommand {
+    public String framework;
+    public List<Command> commands = new ArrayList();
+
+    TestCommand(String framework) {
+      this.framework = framework;
+    }
+  }
+
+  static class Properties {
+    @JSONField(name = "config.app")
+    public String configApp;
+    @JSONField(name = "config.present")
+    public boolean configPresent;
+    @JSONField(name = "config.valid")
+    public boolean configValid;
+    @JSONField(name = "agent.version")
+    public String agentVersion = Status.class.getPackage().getImplementationVersion();
+    @JSONField(name = "project.language")
+    public String projectLanguage = "java";
+    @JSONField(name = "project.remoteRecordingCapable")
+    public boolean projectRemoteRecordingCapable;
+    @JSONField(name = "project.integrationTests")
+    public boolean projectIntegrationTests;
+
+    // Java-specific extensions
+    @JSONField(name = "gradle.present")
+    public boolean gradlePresent;
+    @JSONField(name = "gradle.valid")
+    public boolean gradleValid;
+    @JSONField(name = "maven.present")
+    public boolean mavenPresent;
+    @JSONField(name = "maven.valid")
+    public boolean mavenValid;
+
+    static boolean isConfigValid(Path path) {
+      // Start with simple YAML validation
+      Yaml yaml = new Yaml();
+      InputStream inputStream = null;
+      try {
+        inputStream = Files.newInputStream(path);
+      } catch (IOException e) {
+        // System.err.println(e);
+        return false;
+      }
+      try {
+        yaml.load(inputStream);
+      } catch (RuntimeException e) {
+        // TODO: Good validation messages are available here. An example:
+        /*
+        while scanning a simple key
+         in 'reader', line 7, column 1:
+            xx
+            ^
+        could not find expected ':'
+         in 'reader', line 7, column 3:
+            xx
+              ^
+        */
+        // System.err.println(e);
+        return false;
+      }
+
+      return true;
+    }
+
+    static boolean isGradlePresent(Path projectPath) {
+      return Arrays.stream(new String[]{"build.gradle", "build.gradle.kts"})
+          .map(new Function<String, Path>() {
+            public Path apply(String pathName) {
+              return projectPath.resolve(pathName);
+            }
+          })
+          .filter((Path path) -> Files.exists(path))
+          .anyMatch((path) -> {
+            try {
+              return Files.readAllLines(path).stream().anyMatch((line) -> line.contains("com.appland.appmap"));
+            } catch (IOException e) {
+              return false;
+            }
+          });
+    }
+
+    static boolean isGradleValid(Path projectPath) {
+      // Our doc says that the user can run: gradle appmap test
+      // Try and run gradle --help appmap
+      return Arrays.stream(new String[]{"gradlew", "gradlew.bat"})
+          .map(new Function<String, Path>() {
+            public Path apply(String pathName) {
+              return projectPath.resolve(pathName);
+            }
+          })
+          .filter((Path path) -> Files.exists(path))
+          .anyMatch((commandPath) -> {
+            try {
+              String command = String.format("%s --help appmap", commandPath);
+              // System.err.printf("Attempting: %s\n", command);
+              Process process = Runtime.getRuntime().exec(command);
+              process.waitFor(60, TimeUnit.SECONDS);
+              return process.exitValue() == 0;
+            } catch (IOException | InterruptedException e) {
+              return false;
+            }
+          });
+    }
+
+    static boolean isMavenPresent(Path projectPath) {
+      Path pom = projectPath.resolve("pom.xml");
+      if (!Files.exists(pom)) {
+        return false;
+      }
+
+      try {
+        // This is hokey compared to parsing the pom, but ...
+        return Files.readAllLines(pom).stream().anyMatch((line) -> line.contains("appmap-maven-plugin"));
+      } catch (IOException e) {
+        return false;
+      }
+    }
+
+    static boolean isMavenValid(Path projectPath) {
+      try {
+        // If this works, things are looking pretty good.
+        String command = "mvn prepare-agent";
+        // System.err.printf("Attempting: %s\n", command);
+        Process process = Runtime.getRuntime().exec(command);
+        process.waitFor(60, TimeUnit.SECONDS);
+        return process.exitValue() == 0;
+      } catch (IOException | InterruptedException e) {
+        return false;
+      }
+    }
+  }
+
+  static class Result {
+    @JSONField(name = "test_commands")
+    public List<TestCommand> testCommands = new ArrayList<>();
+    @JSONField
+    public Status.Properties properties = new Status.Properties();
+  }
+
+  public Integer call() {
+    System.err.printf("Reporting AppMap project status in directory: %s\n", parent.directory);
+
+    Path dirPath = FileSystems.getDefault().getPath(parent.directory);
+    Path configPath = dirPath.resolve("appmap.yml");
+
+    Result result = new Result();
+    result.properties.configApp = CLI.projectName(dirPath.toFile());
+    result.properties.configPresent = Files.exists(configPath);
+    if (result.properties.configPresent) {
+      result.properties.configValid = Properties.isConfigValid(configPath);
+    }
+    result.properties.gradlePresent = Properties.isGradlePresent(dirPath);
+    if (result.properties.gradlePresent) {
+      result.properties.gradleValid = Properties.isGradleValid(dirPath);
+    }
+    result.properties.mavenPresent = Properties.isMavenPresent(dirPath);
+    if (result.properties.mavenPresent) {
+      result.properties.mavenPresent = Properties.isMavenValid(dirPath);
+    }
+
+    if (result.properties.gradleValid) {
+      TestCommand tc = new TestCommand("gradle");
+      Arrays.asList(new Program[]{
+          new Program("gradlew", new String[]{"macos", "linux"}),
+          new Program("gradlew.bat", new String[]{"windows"})})
+          .stream()
+          .map(new Function<Program, Command>() {
+        @Override
+        public Command apply(Program program) {
+          Command command = new Command();
+          command.program = program.name;
+          command.args.add("appmap");
+          command.args.add("test");
+          command.platforms = Arrays.asList(program.platforms);
+          return command;
+        }
+      }).collect(new Supplier<List<Command>>() {
+        @Override
+        public List<Command> get() {
+          return tc.commands;
+        }
+      }, List::add, List::addAll);
+      result.testCommands.add(tc);
+    }
+    if (result.properties.mavenValid) {
+      Command command = new Command();
+      command.program = "mvn";
+      command.args.add("test");
+      TestCommand tc = new TestCommand("maven");
+      tc.commands.add(command);
+      result.testCommands.add(tc);
+    }
+
+    parent.getOutputStream().println(JSON.toJSONString(result, SerializerFeature.PrettyFormat));
+
+    return 0;
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/com/appland/appmap/config/AppMapPackage.java b/src/main/java/com/appland/appmap/config/AppMapPackage.java
index 985b285..98ebd79 100644
--- a/src/main/java/com/appland/appmap/config/AppMapPackage.java
+++ b/src/main/java/com/appland/appmap/config/AppMapPackage.java
@@ -25,7 +25,6 @@ public class AppMapPackage {
   /**
    * Returns whether or not the canonical name is explicitly excluded
    * @param canonicalName the canonical name of the class/method to be checked
-   * @return
    */
   public Boolean excludes(String canonicalName) {
     for (String exclusion : this.exclude) {
diff --git a/src/main/java/com/appland/appmap/web/RecordServlet.java b/src/main/java/com/appland/appmap/web/RecordServlet.java
deleted file mode 100644
index 8489422..0000000
--- a/src/main/java/com/appland/appmap/web/RecordServlet.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.appland.appmap.web;
-
-import com.appland.appmap.record.ActiveSessionException;
-import com.appland.appmap.record.IRecordingSession;
-import com.appland.appmap.record.Recorder;
-import com.appland.appmap.util.Logger;
-import com.appland.appmap.config.Properties;
-
-import javax.servlet.annotation.WebServlet;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.PrintWriter;
-
-@WebServlet(name = "RecordServlet", urlPatterns = {"/_appmap/record"}, loadOnStartup = 1) 
-public class RecordServlet extends HttpServlet {
-  private static final Recorder recorder = Recorder.getInstance();
-  private static boolean debug = Properties.DebugHttp;
-
-  @Override
-  protected void doDelete(HttpServletRequest req, HttpServletResponse res) {
-    if (debug) {
-      Logger.println("RecordServlet.doDelete");
-    }
-
-    try {
-      String json = recorder.stop();
-      res.setContentType("application/json");
-      res.setContentLength(json.length());
-
-      PrintWriter writer = res.getWriter();
-      writer.write(json);
-      writer.flush();
-    } catch (ActiveSessionException e) {
-      res.setStatus(HttpServletResponse.SC_NOT_FOUND);
-    } catch (IOException e) {
-      Logger.printf("failed to write response: %s\n", e.getMessage());
-    }
-  }
-
-  @Override
-  protected void doGet(HttpServletRequest req, HttpServletResponse res) {
-    if (debug) {
-      Logger.println("RecordServlet.doGet");
-    }
-
-    res.setStatus(HttpServletResponse.SC_OK);
-
-    String responseJson = String.format("{\"enabled\":%b}", recorder.hasActiveSession());
-    res.setContentType("application/json");
-    res.setContentLength(responseJson.length());
-
-    try {
-      PrintWriter writer = res.getWriter();
-      writer.write(responseJson);
-      writer.flush();
-    } catch (IOException e) {
-      Logger.printf("failed to write response: %s\n", e.getMessage());
-    }
-  }
-
-  @Override
-  protected void doPost(HttpServletRequest req, HttpServletResponse res) {
-    if (debug) {
-      Logger.println("RecordServlet.doPost");
-    }
-
-    IRecordingSession.Metadata metadata = new IRecordingSession.Metadata();
-    metadata.recorderName = "remote_recording";
-    try {
-      recorder.start(metadata);
-    } catch (ActiveSessionException e) {
-      res.setStatus(HttpServletResponse.SC_CONFLICT);
-    }
-  }
-}
diff --git a/test/docker/java11/Dockerfile b/test/docker/java11/Dockerfile
index 46269cb..b2241a5 100644
--- a/test/docker/java11/Dockerfile
+++ b/test/docker/java11/Dockerfile
@@ -31,6 +31,7 @@ RUN git clone https://github.com/bats-core/bats-core.git \
     && ./install.sh /usr/local
 
 COPY --from=petclinic:latest /build /
+COPY --from=petclinic:latest /spring-petclinic /spring-petclinic
 COPY --from=build /build /
 COPY test/appmap.yml     /
 COPY test/entrypoint     /sbin/
diff --git a/test/docker/java8/Dockerfile b/test/docker/java8/Dockerfile
index 6ec379c..8995bc9 100644
--- a/test/docker/java8/Dockerfile
+++ b/test/docker/java8/Dockerfile
@@ -31,6 +31,7 @@ RUN git clone https://github.com/bats-core/bats-core.git \
     && ./install.sh /usr/local
 
 COPY --from=petclinic:latest /build /
+COPY --from=petclinic:latest /spring-petclinic /spring-petclinic
 COPY --from=build /build /
 COPY test/appmap.yml     /
 COPY test/entrypoint     /sbin/
diff --git a/test/helper.bash b/test/helper.bash
index dafa49a..0f64201 100644
--- a/test/helper.bash
+++ b/test/helper.bash
@@ -6,6 +6,10 @@ _curl() {
   curl -H 'Accept: application/json' "${@}"
 }
 
+_appmap() {
+  java -jar /appmap.jar -d /spring-petclinic "${@}"
+}
+
 start_recording() {
   _curl -sXPOST "${WS_URL}/_appmap/record"
 }
